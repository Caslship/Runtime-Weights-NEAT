SharpNeatLib\Decoders
-- FastAcyclicNetworkFactory
---- public static FastAcylicNetwork CreateFastAcylicNetwork(INetworkDefinition)
------ because connections are sorted, I had to create a dictionary for finding target connection indices in the array based off of connection innovation ID
-- CyclicNetworkFactory
---- private static void InternalDecode(INetworkDefinition, out List<Neuron>, out List<Connection>)
------ added in code to allow for connections to reference target connections that contain runtime weights
-- FastCyclicNetworkFactory
---- private static FastConnection [] CreateFastConnectionArray(INetworkDefinition)
------ added in code to allow for fixing of old array indices references for target connections that will be made in InternalDecode()
---- private static void InternalDecode(INetworkDefinition, int, out FastConnection [], out IActivationFunction [], out double [][])
------ added in code to fix references to old FastConnection structures in an array after being sorted

SharpNeatLib\Phenomes\FastAcyclicNetwork
-- class FastAcyclicNetwork : IBlackBox
---- public virtual void Activate()
------ added in code to properly set weights during activation (runtime weights)

SharpNeatLib\Phenomes\FastCyclicNetwork
-- struct FastConnection
---- added instance fields that would aid in implementing the extension and be useful during network activation
-- class FastCyclicNetwork
---- public virtual void Activate()
------ added in code to properly set runtime weights (less checks than FastAcyclicNetwork)
-- class FastRelaxingCyclicNetwork
---- public override void Activate()
------ added in code to properly set runtime weights (less checks than FastAcyclicNetwork)

SharpNeatLib\Phenomes\CyclicNetwork
-- class Connection
---- added instance fields and properties that would aid in implementing the extension and be useful during network activation
---- public Connection(Neuron, Neuron, double, bool, Connection)
------ a constructor which takes into account targeting connections with runtime weights
-- class CyclicNetwork
---- public virtual void Activate()
------ added in code to properly set runtime weights (less checks than FastAcyclicNetwork)
-- class RelaxingCyclicNetwork
---- public override void Activate()
------ added in code to properly set runtime weights (less checks than FastAcyclicNetwork)

SharpNeatLib\Genomes\Neat
-- class ConnectionGene : INetworkConnection
---- added instance fields and properties that would aid in implementing the extension and be useful during decoding
-- class NeatGenome : IGenome<NeatGenome>, INetworkDefinition
---- private void Mutate()
------ added in code to be able to select Mutate_AddRuntimeWeight() and Mutate_DeleteRuntimeWeight() as mutations
---- private void Mutate_ConnectionWeights()
------ not really necessary, but... added checks to make sure that a connection that a contained a runtime weight was not modified
---- ** private NeuronGene Mutate_AddNode() **
------ not sure whether or not I want connection's containing runtime weights or that target runtime weights to be selected just yet...
---- private ConnectionGene Mutate_DeleteConnection()
------ I made sure to leave alone connections containing are targetting runtime weights... Mutate_DeleteRuntimeWeight() will eventually allow them to be deleted
---- private ConnectionGene Mutate_AddRuntimeWeight()
------ added a function in order to physically add runtime weights and begin to build subnetworks that set them
---- private ConnectionGene Mutate_DeleteRuntimeWeight()
------ added a function that removes a connection's potential plasticity properties (disables a runtime weight)... Mutate_DeleteConnection() will take care of them afterwards
-- class NeatGenomeParameters
---- added instance fields and properties which would aid in implementing the extension in the genome concerning mutations
---- public NeatGenomeParameters(bool)
------ a constructor which uses a boolean to enable usage of the extension
---- private RouletteWheelLayout CreateRouletteWheelLayout()
------ added code to set up the probabilities accordingly with inclusion of runtime weights
---- private RouletteWheelLayout CreateRouletteWheelLayout_NonDestructive()
------ added code to set up the probabilities accordingly with inclusion of runtime weights
---- public static NeatGenomeParameters CreateSimplifyingParameters(NeatGenomeParameters)
------ added checks to see if the extension is in use and to adjust probabilities accordingly
-- class NeatGenomeStats
---- added instance fields that tell how many times "Mutate_AddRuntimeWeight()" and "Mutate_DeleteRuntimeWeight()" succesfully performed their intended operations

SharpNeatLib\Network
-- interface INetworkConnection
---- added properties that would aid in implementing the extension and be useful during decoding
-- class NetworkConnection : INetworkConnection
---- just for the hell of it... updated the class to properly implement the INetworkConnection interface now that it uses runtime weights

SharpNeatDomains
-- class SimpleNeatExperiment : IGuiNeatExperiment
---- Added a class that helps simplify the process of creating experiments from http://www.nashcoding.com/category/ai/neural-networks/
---- Modified the class definition to implement IGuiNeatExperiment instead
---- public void Initialize(string, XmlElement)
------ modified the experiment initializer to call a new overloaded version that takes into account the usage of runtime weights extension
---- public void Intialize(string, XmlElement, bool)
------ added in this method that enables or disables use of runtime weight mutations
---- public virtual AbstractGenomeView CreateDomainView()
------ added in this method that potentially enables viewing of problem domain statistics in the SharpNeat GUI
---- public virtual AbstactGenomeView CreateGenomeView()
------ added in this method that potentially enables viewing of genome structure and statistics in the SharpNeat GUI

SharpNeatDomains\AndOrModular
-- Added in code for defining and experiment that tests the capabilites of runtime weights in producing modular behavior

ModularBehavior
-- Added in a program that uses the AndOrModular problem domain in an attempt to test runtime weights

THINGS TO DO
-- class NeatGenome : IGenome<NeatGenome>, INetworkDefinition
---- PerformIntegrityCheck()
------ eventually add code that makes sure runtime weights are set up correctly
-- class ParallelKMeansClusteringStrategy<TGenome> : ISpeciationStrategy<TGenome> where TGenome : class, IGenome<TGenome>
---- have runtime weights affect speciation slightly
-- GET THINGS WORKING WITH HYPERNEAT

POSSIBLE BUG IN ORIGINAL CODE
SharpNeatLib\EvolutionAlgorithms
-- class NeatEvolutionAlgorithm<TGenome> : AbstractGenerationalAlgorithm<TGenome> where TGenome : class IGenome<TGenome>
---- private SpecieStats [] CalcSpecieStats(out int)
------ when adjusting specie _targetSizeInt to make sure that the specie with the best genome doesn't have 0 population allocated, an index one above the champ specie may be selected... this might result in an index out of bounds error